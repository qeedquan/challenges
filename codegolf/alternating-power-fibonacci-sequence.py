#!/usr/bin/env python3

"""

Definition

The Alternating Power Fibonacci Sequence is formed as follows.

Start with the empty sequence and set n to 1.

Compute fn, the nth non-negative Fibonacci number, with repetitions.
0 is the first, 1 is the second and the third, 2 is the fourth. All others are obtained by summing the two previous numbers in the sequence, so 3 = 1 + 2 is the fifth, 5 = 2 + 3 is the sixth, etc.

If n is odd, change the sign of fn.

Append 2n-1 copies of fn to the sequence.

Increment n and go back to step 2.

These are the first one hundred terms of the APF sequence.

 0  1  1 -1 -1 -1 -1  2  2  2  2  2  2  2  2 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
-3 -3 -3 -3 -3 -3  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5
 5  5  5  5  5  5  5  5  5  5  5  5  5 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8
-8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8 -8

Task

Write a full program or a function that takes a positive integer n as input and prints or returns the nth term of the APF sequence.

If you prefer 0-based indexing, you can alternatively take a non-negative integer n and print or return the APF number at index n.

This is code-golf; may the shortest code in bytes win!

Test cases (1-based)
    1 ->    0
    2 ->    1
    3 ->    1
    4 ->   -1
    7 ->   -1
    8 ->    2
  100 ->   -8
  250 ->   13
  500 ->  -21
 1000 ->   34
11111 ->  233
22222 -> -377
33333 ->  610

Test cases (0-based)
    0 ->    0
    1 ->    1
    2 ->    1
    3 ->   -1
    6 ->   -1
    7 ->    2
   99 ->   -8
  249 ->   13
  499 ->  -21
  999 ->   34
11110 ->  233
22221 -> -377
33332 ->  610

"""

"""

@xnor
One-indexed.

The sequence felt like a puzzle, something that Dennis generated by having a short way to express it. The power-of-two repetitions suggest recursing by bit-shifting (floor-dividing by 2). The alternating-sign Fibonacci recursion f(n)=f(n-2)-f(n-1) can be adapted to bitshift in place of decrementing. The base case works out nicely because everything funnels to n=0.

"""

def apfs(n):
    if n < 1:
        return 1
    return apfs(n//4) - apfs(n//2)

def main():
    assert(apfs(1) == 0)
    assert(apfs(2) == 1)
    assert(apfs(3) == 1)
    assert(apfs(4) == -1)
    assert(apfs(7) == -1)
    assert(apfs(8) == 2)
    assert(apfs(100) == -8)
    assert(apfs(250) == 13)
    assert(apfs(500) == -21)
    assert(apfs(1000) == 34)
    assert(apfs(11111) == 233)
    assert(apfs(22222) == -377)
    assert(apfs(33333) == 610)

main()
