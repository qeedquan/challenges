/*

What is 'Rule 30'?
Rule 30 is a particularly special automation because it demonstrates complexity arising from simple rules, chaos and randomness, and is computationally irreducible (i.e. the fastest way to find out what any cell or line will look like after many generations is simply to run the automaton).

It's also Stephen Wolfram's favourite discovery:

Today my all-time favorite science discovery is 40 yrs old! My June 1, 1984 diary told me to "take pict." of "R30" on a 9 pm flight to London ... which is when I finally realized (2 yrs after first generating it) what a big deal rule 30 is...

Further explanation of rule 30.

Challenge
The goal is to generate the first 32 lines of cellular automata rule 30 as represented in ASCII (well, O's and .'s) as per this slightly modified example found on its wikipedia page:

...............................O...............................
..............................OOO..............................
.............................OO..O.............................
............................OO.OOOO............................
...........................OO..O...O...........................
..........................OO.OOOO.OOO..........................
.........................OO..O....O..O.........................
........................OO.OOOO..OOOOOO........................
.......................OO..O...OOO.....O.......................
......................OO.OOOO.OO..O...OOO......................
.....................OO..O....O.OOOO.OO..O.....................
....................OO.OOOO..OO.O....O.OOOO....................
...................OO..O...OOO..OO..OO.O...O...................
..................OO.OOOO.OO..OOO.OOO..OO.OOO..................
.................OO..O....O.OOO...O..OOO..O..O.................
................OO.OOOO..OO.O..O.OOOOO..OOOOOOO................
...............OO..O...OOO..OOOO.O....OOO......O...............
..............OO.OOOO.OO..OOO....OO..OO..O....OOO..............
.............OO..O....O.OOO..O..OO.OOO.OOOO..OO..O.............
............OO.OOOO..OO.O..OOOOOO..O...O...OOO.OOOO............
...........OO..O...OOO..OOOO.....OOOO.OOO.OO...O...O...........
..........OO.OOOO.OO..OOO...O...OO....O...O.O.OOO.OOO..........
.........OO..O....O.OOO..O.OOO.OO.O..OOO.OO.O.O...O..O.........
........OO.OOOO..OO.O..OOO.O...O..OOOO...O..O.OO.OOOOOO........
.......OO..O...OOO..OOOO...OO.OOOOO...O.OOOOO.O..O.....O.......
......OO.OOOO.OO..OOO...O.OO..O....O.OO.O.....OOOOO...OOO......
.....OO..O....O.OOO..O.OO.O.OOOO..OO.O..OO...OO....O.OO..O.....
....OO.OOOO..OO.O..OOO.O..O.O...OOO..OOOO.O.OO.O..OO.O.OOOO....
...OO..O...OOO..OOOO...OOOO.OO.OO..OOO....O.O..OOOO..O.O...O...
..OO.OOOO.OO..OOO...O.OO....O..O.OOO..O..OO.OOOO...OOO.OO.OOO..
.OO..O....O.OOO..O.OO.O.O..OOOOO.O..OOOOOO..O...O.OO...O..O..O.
OO.OOOO..OO.O..OOO.O..O.OOOO.....OOOO.....OOOO.OO.O.O.OOOOOOOOO

Note: this may be a duplicate (or subset of) this previous challenge.

*/

#include <stdio.h>
#include <stdint.h>

void
rule30()
{
	uint64_t state;
	int i, j;

	state = 1ULL << 31;
	for (i = 0; i < 32; i++) {
		for (j = 62; j >= 0; j--) {
			if ((state >> j) & 1)
				printf("O");
			else
				printf(".");
		}
		printf("\n");

		state = (state >> 1) ^ (state | state << 1);
	}
}

int
main()
{
	rule30();
	return 0;
}
