/*

The Compatibility Encoding Scheme for UTF-16: 8-Bit, also known as CESU-8, is a Unicode encoding that is not part of the Unicode standard, but mentioned in a Unicode Technical Report as a compatibility scheme. CESU-8 is a label for an erroneously encoded UTF-8, when a supplementary character (character whose code point is greater than 0xFFFF) is encoded first as a pair of UTF-16 surrogate code units, and each surrogate code unit converted into UTF-8, resulting in a 6-byte sequence for a supplementary character.

The standard UTF-8 encodes a supplementary character into a 4-byte sequence.

The difference between CESU-8 and UTF-8 is on the encoding of supplementary characters only. BMP characters (code point 0xFFFF or lower) have identical encoding in both CESU-8 and UTF-8.

(Unlike UTF-8, CESU-8 is an encoding meant for internal processing and not for open interchange. And for security reasons, a text string cannot mix CESU-8 and UTF-8 sequences, as standard-compliant decoders would decode sequences of one form and reject the other as invalid.)

For this coding challenge, you (the challenger/coder) are to write converters that can convert a CESU-8 sequence of a supplementary character to a standard UTF-8 sequence, and convert the other way around. You may write one converter that accepts both forms of sequences as input, or two separate converters. The converters may be functions or programs.

This challenge does not require you to decode the CESU-8 or UTF-8 byte sequences to the code point, so I am not going to explain how the Unicode code points are encoded to either encoding. Rather, I present the bit distribution difference between UTF-8 and CESU-8, for supplementary characters:

Unicode code point: vvvvvuuuuzzyyyyxxxxxx (21 bits maximum)
UTF-8: 11110vvv 10vvuuuu 10zzyyyy 10xxxxxx (v refers to bits 16 to 20 of the code point and must be in range [00001, 10000] (binary), or equivalently, [1, 16] in decimal.)
CESU-8: 11101101 1010wwww 10uuuuzz 11101101 1011yyyy 10xxxxxx (w is the bit value of v minus 1. The value range of w must be [0000, 1111] (binary), or equivalently, [0, 15] in decimal.)
A diagram and an example conversion (the example character is U+10ACC7, a private-use character):

                   UTF-8   F4(hex)  8A(hex)  B3(hex)  87(hex)
                           -------  -------  -------  -------
                  binary  11110100 10001010 10110011 10000111
                               ---   ------   ------   ------
                               100   001010   110011   000111
                               \_/   \/\__/   \/\__/   \____/
                                \____/  \_____/  |       |
                             ___/       /        |       |
                            /          /         |       |
       /------------\  +-----+   +------+     +----+ +------+
       |   Add 1 /  |--|10000|   |101011|     |0011| |000111|
       | Subtract 1 |  +-----+   +------+     +----+ +------+
       \------------/             /              |       |
                    \            /               |       |
                     \__     ___/                |_     _|__
                     /  \   /    \              /  \   /    \
                     1111   101011              0011   000111
                     ----   ------              ----   ------
binary  11101101 10101111 10101011 11101101 10110011 10000111
         -------  -------  -------  -------  -------  -------
CESU-8   ED(hex)  AF(hex)  AB(hex)  ED(hex)  B3(hex)  87(hex)
(This challenge was inspired by an incorrect answer generated by Google Gemini nearly a year ago. Gemini generated a sequence that claimed to be UTF-8 but in fact was CESU-8. Google had updated the AI model and thus the error cannot be reproduced again.)

Input and output
A CESU-8-to-UTF-8 converter must accept a 6-byte, CESU-8 sequence of a supplementary character as input. It must output the UTF-8 sequence for the character.
A UTF-8-to-CESU-8 converter must accept a 4-byte, UTF-8 sequence of a supplementary character as input. It must output the CESU-8 sequence for the character.
No invalid sequences would be used as input, thus your converters do not need to detect or handle errors. No BMP characters would be used as input, either.
The input data type may be a byte array (with fixed length), or an integer that concatenates all bits of the sequence. If you choose to input an integer, you must indicate the endianness in the text of your submission, as I intend the submissions of different endianness compete separately.
Additional requirements
You may choose to implement the converter in one combined function or two functions.
code-golf. Aim for code size as small as possible.
If the converter is implemented in two functions, the code sizes of two functions will be added up as the score. (The code size is counted as if both functions are in the same source file; you may share code between two functions without doubling the code size).
The use of the following features or functions are allowed (I'm not sure if using any of these can bring significant advantage to your submission, but if it does, tell us so):
Byte swap functions
UTF-8 encode and decode functions
Test data
The code points and character names here are for reference purposes. You are not required to decode or output the code point. It's just the conversion that matters.

EDA080EDB080 <--> F0908080 (U+10000 "Linear B Syllable B008 A")

EDA080EDBFBF <--> F0908FBF (U+103FF [Unassigned as of Unicode 16.0])
EDA083EDB080 <--> F090B080 (U+10C00 "Old Turkic Letter Orkhon A")
EDA08CEDB080 <--> F0938080 (U+13000 "Egyptian Hieroglyph A001")
EDA0B0EDB080 <--> F09C8080 (U+1C000 [Unassigned as of Unicode 16.0])

EDA180EDB080 <--> F0A08080 (U+20000 "CJK Unified Ideograph-20000")
EDA280EDB080 <--> F0B08080 (U+30000 "CJK Unified Ideograph-30000")
EDA380EDB080 <--> F1808080 (U+40000 [Unassigned as of Unicode 16.0])
EDA480EDB080 <--> F1908080 (U+50000 [Unassigned as of Unicode 16.0])

EDA780EDB080 <--> F2808080 (U+80000 [Unassigned as of Unicode 16.0])
EDAE80EDB080 <--> F3B08080 (U+F0000 "Supplementary Private Use Area-A")
EDAF80EDB080 <--> F4808080 (U+100000 "Supplementary Private Use Area-B")

EDAFBFEDBFBF <--> F48FBFBF (U+10FFFF [Noncharacter])
Sample (non-golf) implementation
Both big-endian version and little-endian versions are provided here (all written by me). If you use my code, please give me proper credit.

#define assert(x) // No-op
// Assumptions: (LONG_WIDTH >= 32 && LLONG_WIDTH >= 64)

// Big endian version
unsigned long cesu8_to_utf8_be(unsigned long long seq) {
    assert((seq | 0x000F3F000F3FULL) == 0xEDAFBFEDBFBFULL);
    unsigned long temp = (unsigned long)((seq >> 12) - 0xED9F80EDBULL);
    temp += (temp & 0x01C3C000UL) * 3;
    return (temp | (seq & 0xF3F) | 0xF0808080UL);
}
unsigned long long utf8_to_cesu8_be(unsigned long seq) {
    assert((seq | 0x073F3F3FUL) == 0xF7BFBFBFUL);
    assert(seq >= 0xF0908080UL);
    assert(seq <= 0xF48FBFBFUL);
    unsigned long long temp = 0xE9DD7EEDB080ULL + (seq & 0xF3F);
    seq += (seq & 0x00303000UL) * 3;
    return temp + ((unsigned long long)(seq >> 12) << 22);
}

// Little endian version
unsigned long cesu8_to_utf8_le(unsigned long long seq) {
    assert((seq | 0x3F0F003F0F00ULL) == 0xBFBFEDBFAFEDULL);
    seq -= 0x80B0ED809FEDULL;
    unsigned long temp = ((seq << 4) | (seq >> 10)) & 0x303F07UL;
    return temp | ((seq >> 16) & 0x3F0F0000UL) | 0x808080F0UL;
}
unsigned long long utf8_to_cesu8_le(unsigned long seq) {
    unsigned long long temp = (seq & 0x3F0F0000ULL) << 16;
    temp |= (seq & 0x0F07) << 10;
    temp += (seq >> 4) & 0x030300UL;
    return temp + 0x80B0ED809FEDULL;
}

*/

package main

func main() {
	assert(cesu8_to_utf8_be(0xEDA080EDB080) == 0xF0908080)

	assert(cesu8_to_utf8_be(0xEDA080EDBFBF) == 0xF0908FBF)
	assert(cesu8_to_utf8_be(0xEDA083EDB080) == 0xF090B080)
	assert(cesu8_to_utf8_be(0xEDA08CEDB080) == 0xF0938080)
	assert(cesu8_to_utf8_be(0xEDA0B0EDB080) == 0xF09C8080)

	assert(cesu8_to_utf8_be(0xEDA180EDB080) == 0xF0A08080)
	assert(cesu8_to_utf8_be(0xEDA280EDB080) == 0xF0B08080)
	assert(cesu8_to_utf8_be(0xEDA380EDB080) == 0xF1808080)
	assert(cesu8_to_utf8_be(0xEDA480EDB080) == 0xF1908080)

	assert(cesu8_to_utf8_be(0xEDA780EDB080) == 0xF2808080)
	assert(cesu8_to_utf8_be(0xEDAE80EDB080) == 0xF3B08080)
	assert(cesu8_to_utf8_be(0xEDAF80EDB080) == 0xF4808080)

	assert(cesu8_to_utf8_be(0xEDAFBFEDBFBF) == 0xF48FBFBF)
}

func assert(x bool) {
	if !x {
		panic("assertion failed")
	}
}

func cesu8_to_utf8_be(seq uint64) uint32 {
	temp := uint32((seq >> 12) - 0xED9F80EDB)
	temp += (temp & 0x01C3C000) * 3
	return (temp | uint32(seq&0xF3F) | 0xF0808080)
}

func utf8_to_cesu8_be(seq uint32) uint64 {
	temp := 0xE9DD7EEDB080 + uint64(seq&0xF3F)
	seq += (seq & 0x00303000) * 3
	return temp + (uint64(seq>>12) << 22)
}

func cesu8_to_utf8_le(seq uint64) uint32 {
	seq -= 0x80B0ED809FED
	temp := uint32(((seq << 4) | (seq >> 10)) & 0x303F07)
	return temp | uint32((seq>>16)&0x3F0F0000) | 0x808080F0
}

func utf8_to_cesu8_le(seq uint32) uint64 {
	temp := uint64(seq&0x3F0F0000) << 16
	temp |= uint64(seq&0x0F07) << 10
	temp += uint64(seq>>4) & 0x030300
	return temp + 0x80B0ED809FED
}
