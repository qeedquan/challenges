#!/usr/bin/env python3

"""

A positive integer may be represented in an integer base 1â‰¤b<âˆ.

When converted to that base it has some number of distinct digits.

Any positive integer in base 1 has 1 distinct digit.

Most positive integers in base 2 have 2 distinct digits, the exceptions being those of the form 2^n-1, which only have 1.

So the first positive integer that may be represented in an integer base with 1 unique digit is 1 and the first that may be represented with 2 distinct digits is 2.

We can say that 1 is the first integer with digital diversity 1 and 2 is the first integer with digital diversity 2.

Challenge:
Given a positive integer n return the first positive integer (in base ten*) that has a digital diversity of n.

* if your language only supports a specific base (e.g. unary or binary) then you may output in that base.

Your algorithm must work in theory for any positive integer input: it may fail because the precision of your language's integer is too small for the output; but may not fail because base conversion is only defined up to some limit.

Test cases
input  output
   1     1
   2     2
   3     11
   4     75
   5     694
   6     8345
   7     123717
  17     49030176097150555672
  20     5271200265927977839335179
  35     31553934355853606735562426636407089783813301667210139
  63     3625251781415299613726919161860178255907794200133329465833974783321623703779312895623049180230543882191649073441
 257     87678437238928144977867204156371666030574491195943247606217411725999221158137320290311206746021269051905957869964398955543865645836750532964676103309118517901711628268617642190891105089936701834562621017362909185346834491214407969530898724148629372941508591337423558645926764610261822387781382563338079572769909101879401794746607730261119588219922573912353523976018472514396317057486257150092160745928604277707892487794747938484196105308022626085969393774316283689089561353458798878282422725100360693093282006215082783023264045094700028196975508236300153490495688610733745982183150355962887110565055971546946484175232

This is code-golf, the shortest solution in bytes wins.

OEIS: A049363 - also smallest pandigital number in base n.

"""

# https://oeis.org/A049363
def diversity(n):
    if n < 0:
        return 0

    r = n
    for i in range(2, n):
        r = r*n + i
    return r

def main():
    assert(diversity(1) == 1)
    assert(diversity(2) == 2)
    assert(diversity(3) == 11)
    assert(diversity(4) == 75)
    assert(diversity(5) == 694)
    assert(diversity(6) == 8345)
    assert(diversity(7) == 123717)
    assert(diversity(17) == 49030176097150555672)
    assert(diversity(20) == 5271200265927977839335179)
    assert(diversity(35) == 31553934355853606735562426636407089783813301667210139)
    assert(diversity(63) == 3625251781415299613726919161860178255907794200133329465833974783321623703779312895623049180230543882191649073441)
    assert(diversity(257) == 87678437238928144977867204156371666030574491195943247606217411725999221158137320290311206746021269051905957869964398955543865645836750532964676103309118517901711628268617642190891105089936701834562621017362909185346834491214407969530898724148629372941508591337423558645926764610261822387781382563338079572769909101879401794746607730261119588219922573912353523976018472514396317057486257150092160745928604277707892487794747938484196105308022626085969393774316283689089561353458798878282422725100360693093282006215082783023264045094700028196975508236300153490495688610733745982183150355962887110565055971546946484175232)

main()
