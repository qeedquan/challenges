/*

Given two integers greater than one, A and B, output four mathematical expressions in this order:

1. The plain expression A^B (A to the power B). e.g. if A = 2 and B = 3, 2^3.
2. The expansion of A^B in terms of repeated multiplications of A. e.g. 2*2*2.
3. The expansion of A^B in terms of repeated additions of A. e.g. 2+2+2+2.
4. The expansion of A^B in terms of repeated additions of 1. e.g. 1+1+1+1+1+1+1+1.

The four expressions may be output in any reasonable way as long as they are in order and clearly distinct. For example, you might put them in a list, or print them on separate lines

2^3
2*2*2
2+2+2+2
1+1+1+1+1+1+1+1
or perhaps on one line separated by equals signs:

2^3=2*2*2=2+2+2+2=1+1+1+1+1+1+1+1
Spaces may be inserted next to math operators so

2^3 = 2 * 2 * 2 = 2 + 2 + 2 + 2 = 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
would be equally valid output when A = 2 and B = 3.

You may use symbols alternative to ^, *, and +, but only if the new symbols are more idiomatic for your language (e.g. ** instead of ^ in Python).

You may assume that A and B are sufficiently small so that A^B will not overflow your language's default integer type (given that that type has a reasonable maximum, 255 at least).

The shortest code in bytes wins.

Test Cases
One output per line. The input can be inferred as the first expression is always A^B.

2^2 = 2*2 = 2+2 = 1+1+1+1
2^3 = 2*2*2 = 2+2+2+2 = 1+1+1+1+1+1+1+1
2^4 = 2*2*2*2 = 2+2+2+2+2+2+2+2 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
2^5 = 2*2*2*2*2 = 2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
3^2 = 3*3 = 3+3+3 = 1+1+1+1+1+1+1+1+1
3^3 = 3*3*3 = 3+3+3+3+3+3+3+3+3 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
3^4 = 3*3*3*3 = 3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
3^5 = 3*3*3*3*3 = 3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
4^2 = 4*4 = 4+4+4+4 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
4^3 = 4*4*4 = 4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
10^2 = 10*10 = 10+10+10+10+10+10+10+10+10+10 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1
13^2 = 13*13 = 13+13+13+13+13+13+13+13+13+13+13+13+13 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1

*/

package main

import (
	"bytes"
	"fmt"
)

func main() {
	assert(expand("2^2") == "2^2 = 2*2 = 2+2 = 1+1+1+1")
	assert(expand("2^3") == "2^3 = 2*2*2 = 2+2+2+2 = 1+1+1+1+1+1+1+1")
	assert(expand("2^4") == "2^4 = 2*2*2*2 = 2+2+2+2+2+2+2+2 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("2^5") == "2^5 = 2*2*2*2*2 = 2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("3^2") == "3^2 = 3*3 = 3+3+3 = 1+1+1+1+1+1+1+1+1")
	assert(expand("3^3") == "3^3 = 3*3*3 = 3+3+3+3+3+3+3+3+3 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("3^4") == "3^4 = 3*3*3*3 = 3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("3^5") == "3^5 = 3*3*3*3*3 = 3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3+3 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("4^2") == "4^2 = 4*4 = 4+4+4+4 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("4^3") == "4^3 = 4*4*4 = 4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("10^2") == "10^2 = 10*10 = 10+10+10+10+10+10+10+10+10+10 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
	assert(expand("13^2") == "13^2 = 13*13 = 13+13+13+13+13+13+13+13+13+13+13+13+13 = 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1")
}

func assert(x bool) {
	if !x {
		panic("assertion failed")
	}
}

func expand(s string) string {
	var a, b int
	_, err := fmt.Sscanf(s, "%v^%v", &a, &b)
	if err != nil {
		return "invalid expression"
	}

	n := ipow(a, b)
	w := new(bytes.Buffer)
	fmt.Fprintf(w, "%v^%v = %v = %v = %v", a, b, repeat(a, b, '*'), repeat(a, n/a, '+'), repeat(1, n, '+'))
	return w.String()
}

func repeat(v, n int, c rune) string {
	w := new(bytes.Buffer)
	for i := 0; i < n; i++ {
		fmt.Fprint(w, v)
		if i+1 < n {
			fmt.Fprintf(w, "%c", c)
		}
	}
	return w.String()
}

func ipow(x, p int) int {
	r := 1
	for i := 0; i < p; i++ {
		r *= x
	}
	return r
}
