#!/usr/bin/env python3

"""

(yes, "generating generating" in the title is correct :) )

Context
In middle (?) school we are taught about sequences and, in particular, we are taught about linear sequences where the nth term is generated with an expression of the form an + b, where a and b are some coefficients.
In this challenge, we will deal with sequences generated by polynomials of arbitrary degree.

Task
Given the first m terms of a sequence, find the coefficients of the polynomial of lowest degree that could have generated such a sequence.

A polynomial, and thus the generating expression you are looking for, is to be seen as a function p(n) that takes n as an argument and returns

a0 + a1*n + a2*n^2 + ... ak*n^k

where k≥0 and ai,0≤i≤k have to be found by you.

You will assume that the m terms you were given correspond to taking n = 0, n = 1, ..., n = m-1 in the generating polynomial above.

Examples
If I am given the sequence [2, 2, 2] then I realize this is a constant sequence and can be generated by a polynomial of degree 0: p(n) = 2.

If I am given the sequence [1, 2, 3] then I realize this cannot come from a constant polynomial but it could come from a linear polynomial p(n) = n + 1, so that is what my output should be. Notice how

p(0) = 1
p(1) = 2
p(2) = 3    # and NOT p(1) = 1, p(2) = 2, p(3) = 3

Input
Your input will be the first terms of a sequence, which you can take in any reasonable format/data type. A standard list is the most obvious choice.

You may assume the input sequence is composed of integers (positive, 0 and negative).

Output
The coefficients of the polynomial of lowest degree that could have generated the input sequence.
The output format can be in any sensible way, as long as the coefficients can be retrieved unambiguously from the output.
For this, both the value of each coefficient and the degree of each coefficient are important. (e.g. if using a list, [1, 0, 2] is different from [0, 1, 2]).

You can assume the polynomial you are looking for has integer coefficients.

Test cases
For these test cases, the input is a list with the first terms; the output is a list of coefficients where (0-based) indices represent the coefficients, so [1, 2, 3] represents 1 + 2x + 3x^2.

[-2] -> [-2]
[0, 0] -> [0]
[2, 2, 2] -> [2]
[4, 4] -> [4]
[-3, 0] -> [-3, 3]
[0, 2, 4, 6] -> [0, 2]
[2, 6] -> [2, 4]
[3, 7] -> [3, 4]
[4, 8, 12, 16] -> [4, 4]
[-3, -1, 5, 15, 29] -> [-3, 0, 2]
[0, 1, 4, 9] -> [0, 0, 1]
[3, 2, 3, 6, 11] -> [3, -2, 1]
[3, 4, 13, 30, 55] -> [3, -3, 4]
[4, 12, 28, 52, 84] -> [4, 4, 4]
[2, 4, 12, 32, 70] -> [2, 1, 0, 1]
[3, 6, 21, 54] -> [3, -1, 3, 1]
[4, 2, 12, 52, 140] -> [4, -2, -3, 3]
[10, 20, 90, 280] -> [10, 0, 0, 10]
[-2, 8, 82, 352, 1022, 2368, 4738] -> [-2, 4, -1, 4, 3]
[4, 5, 32, 133, 380] -> [4, -2, 0, 2, 1]
[1, 0, 71, 646, 2877, 8996, 22675] -> [1, -1, 0, -3, 0, 3]
[4, 2, 60, 556, 2540, 8094, 20692] -> [4, -2, -1, 0, -2, 3]
[1, 2, -17, 100, 1517, 7966, 28027, 78128, 186265] -> [1, 3, -2, 4, -3, -2, 1]
[4, 5, 62, 733, 4160, 15869, 47290, 118997] -> [4, 3, -1, -3, 1, 0, 1]
Test cases generated with this code

This is code-golf so shortest submission in bytes, wins! If you liked this challenge, consider upvoting it! If you dislike this challenge, please give me your feedback. Happy golfing!

"""

import numpy as np

"""

@Arnauld

How?
We use Cramer's rule to solve a system of linear equations based on a square Vandermonde matrix:

Given an input vector of length n, we build a Vandermonde matrix Vn of size n×n with coefficients αi=i,0≤i<n

Vn = 1 0 0 ... 0
     1 1 1 ... 1
     1 2 4 ... 2^(n-1)
     . . . . . .
     . . . . . .
     . . . . . .
     1 n-1 (n-1)^2 (n-1)^(n-1)

Using Cramer's rule, the coefficient ai of the polynomial is computed by taking the determinant of the matrix obtained by replacing the i-th column of Vn with the input vector, and dividing by the determinant of Vn.

Example for (4, 2, 15, 52, 140)

M0 =   4  0  0  0   0
       2  1  1  1   1
      12  2  4  8  16
      52  3  9 27  81
     140  4 16 64 256
a0 = det(M0)/det(V5) = 1152/288 = 4

M0 = 1   4  0  0   0
     1   2  1  1   1
     1  12  4  8  16
     1  52  9 27  81
     1 140 16 64 256
a1 = det(M1)/det(V5) = -576/288 = -2

"""
def gfe(a):
    n = len(a)
    if n == 0:
        return []

    c = np.linspace(0, n - 1, n, dtype=int)
    V = np.vander(c, increasing=True)
    d = np.linalg.det(V)

    r = []
    for i in range(n):
        W = V.copy()
        W[:, i] = a
        x = np.linalg.det(W) / d
        r.append(round(x))

    r = np.trim_zeros(r, 'b')
    if len(r) == 0:
        r = [0]

    return r

def main():
    assert(gfe([]) == [])
    assert(gfe([-2]) == [-2])
    assert(gfe([0, 0]) == [0])
    assert(gfe([2, 2, 2]) == [2])
    assert(gfe([4, 4]) == [4])
    assert(gfe([-3, 0]) == [-3, 3])
    assert(gfe([0, 2, 4, 6]) == [0, 2])
    assert(gfe([2, 6]) == [2, 4])
    assert(gfe([3, 7]) == [3, 4])
    assert(gfe([4, 8, 12, 16]) == [4, 4])
    assert(gfe([-3, -1, 5, 15, 29]) == [-3, 0, 2])
    assert(gfe([0, 1, 4, 9]) == [0, 0, 1])
    assert(gfe([3, 2, 3, 6, 11]) == [3, -2, 1])
    assert(gfe([3, 4, 13, 30, 55]) == [3, -3, 4])
    assert(gfe([4, 12, 28, 52, 84]) == [4, 4, 4])
    assert(gfe([2, 4, 12, 32, 70]) == [2, 1, 0, 1])
    assert(gfe([3, 6, 21, 54]) == [3, -1, 3, 1])
    assert(gfe([4, 2, 12, 52, 140]) == [4, -2, -3, 3])
    assert(gfe([10, 20, 90, 280]) == [10, 0, 0, 10])
    assert(gfe([-2, 8, 82, 352, 1022, 2368, 4738]) == [-2, 4, -1, 4, 3])
    assert(gfe([4, 5, 32, 133, 380]) == [4, -2, 0, 2, 1])
    assert(gfe([1, 0, 71, 646, 2877, 8996, 22675]) == [1, -1, 0, -3, 0, 3])
    assert(gfe([4, 2, 60, 556, 2540, 8094, 20692]) == [4, -2, -1, 0, -2, 3])
    assert(gfe([1, 2, -17, 100, 1517, 7966, 28027, 78128, 186265]) == [1, 3, -2, 4, -3, -2, 1])
    assert(gfe([4, 5, 62, 733, 4160, 15869, 47290, 118997]) == [4, 3, -1, -3, 1, 0, 1])

main()
