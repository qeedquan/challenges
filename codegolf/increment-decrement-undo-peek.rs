/*

Write a program or function (hereafter "function") that returns or prints the source code of four new functions: Increment, decrement, undo, and peek.

The initial function contains an internal integer value of 0. Each of the returned functions contains a value based on that value, and each behaves differently:

Increment contains the value of the function that created it plus 1. When called, it returns or prints the source code of four new functions: Increment, decrement, undo, and peek.

Decrement contains the value of the function that created it minus 1. When called, it returns or prints the source code of four new functions: Increment, decrement, undo, and peek.

Undo returns increment, decrement, undo, and peek functions equivalent to those returned by the function that created the function that created it, i.e. its grandparent. Calling successive Undo functions will return functions earlier and earlier in the "history." Note: Because the very first generation of Undo has no "grandparent" its behavior is undefined. It may return any value, throw an error, etc.

Peek contains the value of the function that created it. When called it returns or prints that value.

Example
Suppose yourFunction is your initial function. It returns four strings that contain the source code of the subsequent functions.

[incr, decr, undo, peek] = yourFunction();
eval(peek)(); // => 0

[incrB, decrB, undoB, peekB] = eval(incr)();
eval(peekB)(); // => 1

[incrC, decrC, undoC, peekC] = eval(incrB)();
eval(peekC)(); // => 2

[incrD, decrD, undoD, peekD] = eval(incrC)();
eval(peekD)(); // => 3

[incrE, decrE, undoE, peekE] = eval(undoD)();
eval(peekE)(); // => 2

[incrF, decrF, undoF, peekF] = eval(undoE)();
eval(peekF)(); // => 1

[incrG, decrG, undoG, peekG] = eval(decrF)();
eval(peekG)(); // => 0
eval(peekF)(); // => 1
Rules
This is a code-generation challenge. With the exception of "peek," the initial function and the functions it creates (and the functions they create and so on) must return source code that can be stored (copied/pasted, saved in a file, et al) and executed in a separate session. Returning a closure, for example, is not valid.

The functions generated don't need to be named "increment," "decrement," etc. They're not required to be named at all.

The "depth" of the Undo functions, i.e. how far back you can go in their "history," should be limited only by memory or language constraints.

You're encouraged to include in your answer examples of the four functions generated by your initial function or its successors.

The output formats are flexible. Inclusive of rule (1), standard I/O rules apply; your initial function—and the subsequent functions—could return four programs separated by newlines; an array of four strings; an object with four string properties; four files; etc.

Standard rules apply and standard loopholes are forbidden.

This is code-golf. Your score is the number of bytes in your initial function. Lowest number of bytes wins.

*/

// ported from @mousetail solution
fn main() {
    let m=("fn ","(){let m=",";let n=vec!",";println!(\"fn a(){{println!(\\\"","\\\")}}\");for i in [(\"b\",",",\"\"),(\"c\",",",\"\"),(\"d\",",",\"o.pop();\")]{let mut o=n.clone();o.push(i.1);","println!(\"{}{}{}{:?}{}{:?}{}{}{}{}{}{}{}{}{}{}{}\",m.0,i.0,m.1,m,m.2,o,m.3,i.1,m.4,i.1+1,m.5,i.1-1,m.6,o[o.len()-2],m.7,i.2,m.8);}}");
    let n = vec![0, 0];
    println!("fn a(){{println!(\"0\")}}");
    for i in [("b", 1, ""), ("c", -1, ""), ("d", 0, "o.pop();")] {
        let mut o = n.clone();
        o.push(i.1);
        println!(
            "{}{}{}{:?}{}{:?}{}{}{}{}{}{}{}{}{}{}{}",
            m.0,
            i.0,
            m.1,
            m,
            m.2,
            o,
            m.3,
            i.1,
            m.4,
            i.1 + 1,
            m.5,
            i.1 - 1,
            m.6,
            o[o.len() - 2],
            m.7,
            i.2,
            m.8
        );
    }
}
