/*

The Cartesian plane can be tiled with increasingly large squares like so:

https://i.sstatic.net/xFxRUjni.png

This tiling can be generated by starting with a square of side length 1, placed at the origin 0, 0, and then repeatedly adding a square to the side of the resulting rectangle anticlockwise of the previous square, starting on the right. The first few iterations look like this:

https://i.sstatic.net/9QnOuFsKm.png

Your challenge is to, given a coordinate (x, y) on the plane, return the side length of the square covering that coordinate. For example:

https://i.sstatic.net/pB4BuDkf.png

From the construction above, a square with side length 1 is placed at (0, 0), so (0, 0) should result in 1. However, the tile one square above and to the right at (1, 1) is covered by a square of side length 2, so (1, 1) should result in 2. Similarly, the coordinate 2 tiles to the left of the origin, (-2, 0), should result in 3, and (3, -2) should result in 8.

You may take x and y swapped and/or negated - equivalently, you may index into any rotation or reflection of the tiling. This is code-golf, shortest wins!

Testcases
These use the coordinate system from above, using x, y -> size.

0, 0 -> 1
1, 0 -> 1
1, 1 -> 2
-3, 1 -> 3
-3, -1 -> 5
3, -2 -> 8
6, 15 -> 13
-4, -5 -> 21
-4, -6 -> 34
145, 214 -> 610

*/

package main

func main() {
	assert(fibtile(0, 0) == 1)
	assert(fibtile(1, 0) == 1)
	assert(fibtile(1, 1) == 2)
	assert(fibtile(-3, 1) == 3)
	assert(fibtile(-3, -1) == 5)
	assert(fibtile(3, -2) == 8)
	assert(fibtile(6, 15) == 13)
	assert(fibtile(-4, -5) == 21)
	assert(fibtile(-4, -6) == 34)
	assert(fibtile(145, 214) == 610)
}

func assert(x bool) {
	if !x {
		panic("assertion failed")
	}
}

/*

@l4m2

If in the rect then output its height, otherwise rotate by 90 and extend to right

*/

func fibtile(x, y int) int {
	return recurse(x, y, 0, 0, 1, 0)
}

func recurse(x, y, l, u, r, d int) int {
	if x < l || x > r || y < d || y > u {
		return recurse(y, -x, d, -l, u+r+1-l, -r)
	}
	return u - d + 1
}
