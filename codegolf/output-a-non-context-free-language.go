/*

Your challenge is to write a program which will output a non-context-free language.

A Context-free Grammar is a series of replacement rules, describing which symbols can be replaced by which other symbols. It defines set of strings, known as a language, which is generated by performing all possible replacement rules on an initial symbol until no more replacements can be made.

Any language which can be generated this way is known as a context-free language.

Your challenge is to write a program which will output a language which cannot be generated this way.

Details:

Output your language in increasing order of length. Ordering between strings of a given length is up to you.
As all CSLs are infinite, your program must not halt.
The strings must be separated from each other. However, you may choose the separation.
Please include in your answer a description of the language you generate and an explanation of why it is not context-free.
One possible way to prove this is by using the pumping lemma.
Example context-sensitive language: [abc, aabbcc, aaabbbccc, aaaabbbbcccc, ...]
Scoring: For all programs which can be encoded in ASCII or another 7 bit or less character set, scoring is by character. For all other programs, scoring is (# of bits in binary encoding)/7.

Feel free to ask questions.

*/

package main

import (
	"fmt"
	"math/big"
)

func main() {
	output()
}

/*

@xnor

Prints the language of strings in the symbol 1 whose length is a power of 2, i.e {"1"*(2**n) | n>=0}. The s+=s is equivalent to s*=2; it doubles the string each time.

Since unary (one-symbol) CFG's are regular, and unary regular CFG's are periodic past a point, this cannot be regular and thus is not a CFG.
Alternatively, use the pumping lemma to see that the possible lengths of words in a CFL must have finite density and can't have arbitrarily large gaps.

*/

func output() {
	var (
		one = big.NewInt(1)
	)

	x := big.NewInt(1)
	i := new(big.Int)
	for {
		for i.SetInt64(0); x.Cmp(i) != 0; i.Add(i, one) {
			fmt.Print("1")
		}
		fmt.Println()
		x.Lsh(x, 1)
	}
}
