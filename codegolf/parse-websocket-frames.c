/*

According to MDN, every WebSocket message is sent as one or more frames. Your job is to extract the payload given a (masked) client-to-server text frame. The steps to extract the payload is as follows:

ignore byte 1; read byte 2
if it is 254, skip the next 2 bytes
if it is 255, skip the next 8 bytes,
otherwise, continue
interpret the next 4 bytes as an XOR-cipher key
decrypt the final bytes using the (repeating) key and interpret it as a UTF-8 encoded string
For reference, here is an ungolfed solution:

#!/usr/bin/env python3
frame = open(0, 'rb').read()

pos = 2
if frame[1] == 254:
    pos += 2 # skip 2 bytes
if frame[1] == 255:
    pos += 8 # skip 8 bytes

# read the key (4 bytes)
key = frame[pos:][:4]
pos += 4

# decode the payload
payload = bytes(x ^ key[i % 4] for i, x in enumerate(frame[pos:]))

# output
print(payload.decode("utf-8"))

Test Cases
frame (octets are represented in hex)	payload
81 83 3D 54 23 06 70 10 6D	MDN
81 85 3D 54 23 06 55 31 4F 6A 52	hello
81 FE 01 BD 3D 54 23 06 71 3B 51 63 50 74 4A 76 4E 21 4E 26 59 3B 4F 69 4F 74 50 6F 49 74 42 6B 58 20 0F 26 5E 3B 4D 75 58 37 57 63 49 21 51 26 5C 30 4A 76 54 27 40 6F 53 33 03 63 51 3D 57 2A 1D 27 46 62 1D 30 4C 26 58 3D 56 75 50 3B 47 26 49 31 4E 76 52 26 03 6F 53 37 4A 62 54 30 56 68 49 74 56 72 1D 38 42 64 52 26 46 26 58 20 03 62 52 38 4C 74 58 74 4E 67 5A 3A 42 26 5C 38 4A 77 48 35 0D 26 68 20 03 63 53 3D 4E 26 5C 30 03 6B 54 3A 4A 6B 1D 22 46 68 54 35 4E 2A 1D 25 56 6F 4E 74 4D 69 4E 20 51 73 59 74 46 7E 58 26 40 6F 49 35 57 6F 52 3A 03 73 51 38 42 6B 5E 3B 03 6A 5C 36 4C 74 54 27 03 68 54 27 4A 26 48 20 03 67 51 3D 52 73 54 24 03 63 45 74 46 67 1D 37 4C 6B 50 3B 47 69 1D 37 4C 68 4E 31 52 73 5C 20 0D 26 79 21 4A 75 1D 35 56 72 58 74 4A 74 48 26 46 26 59 3B 4F 69 4F 74 4A 68 1D 26 46 76 4F 31 4B 63 53 30 46 74 54 20 03 6F 53 74 55 69 51 21 53 72 5C 20 46 26 4B 31 4F 6F 49 74 46 75 4E 31 03 65 54 38 4F 73 50 74 47 69 51 3B 51 63 1D 31 56 26 5B 21 44 6F 5C 20 03 68 48 38 4F 67 1D 24 42 74 54 35 57 73 4F 7A 03 43 45 37 46 76 49 31 56 74 1D 27 4A 68 49 74 4C 65 5E 35 46 65 5C 20 03 65 48 24 4A 62 5C 20 42 72 1D 3A 4C 68 1D 24 51 69 54 30 46 68 49 78 03 75 48 3A 57 26 54 3A 03 65 48 38 53 67 1D 25 56 6F 1D 3B 45 60 54 37 4A 67 1D 30 46 75 58 26 56 68 49 74 4E 69 51 38 4A 72 1D 35 4D 6F 50 74 4A 62 1D 31 50 72 1D 38 42 64 52 26 56 6B 13	Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

Standard loopholes are forbidden. Shortest code wins.

*/

#define _GNU_SOURCE
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <errno.h>

ssize_t
deframe(const uint8_t *frame, size_t framelen, uint8_t *payload)
{
	const uint8_t *key;
	size_t pos;
	ssize_t cnt;

	if (framelen < 2)
		return -EMSGSIZE;

	pos = 2;
	if (frame[1] == 0xfe)
		pos += 2;
	else if (frame[1] == 0xff)
		pos += 8;

	if (pos + 4 >= framelen)
		return -EMSGSIZE;
	key = frame + pos;
	pos += 4;

	for (cnt = 0; pos < framelen; cnt++)
		payload[cnt] = frame[pos++] ^ key[cnt & 3];

	return cnt;
}

void
test(const uint8_t *frame, size_t framelen, const void *expected, ssize_t expectedlen)
{
	uint8_t payload[512];
	ssize_t len;

	len = deframe(frame, framelen, payload);
	assert(len == expectedlen);
	assert(!memcmp(payload, expected, len));
}

int
main(void)
{
	uint8_t frame1[] = {0x81, 0x83, 0x3D, 0x54, 0x23, 0x06, 0x70, 0x10, 0x6D};
	char expected1[] = "MDN";

	uint8_t frame2[] = {0x81, 0x85, 0x3D, 0x54, 0x23, 0x06, 0x55, 0x31, 0x4F, 0x6A, 0x52};
	char expected2[] = "hello";

	uint8_t frame3[] = {0x81, 0xFE, 0x01, 0xBD, 0x3D, 0x54, 0x23, 0x06, 0x71, 0x3B, 0x51, 0x63, 0x50, 0x74, 0x4A, 0x76, 0x4E, 0x21, 0x4E, 0x26, 0x59, 0x3B, 0x4F, 0x69, 0x4F, 0x74, 0x50, 0x6F, 0x49, 0x74, 0x42, 0x6B, 0x58, 0x20, 0x0F, 0x26, 0x5E, 0x3B, 0x4D, 0x75, 0x58, 0x37, 0x57, 0x63, 0x49, 0x21, 0x51, 0x26, 0x5C, 0x30, 0x4A, 0x76, 0x54, 0x27, 0x40, 0x6F, 0x53, 0x33, 0x03, 0x63, 0x51, 0x3D, 0x57, 0x2A, 0x1D, 0x27, 0x46, 0x62, 0x1D, 0x30, 0x4C, 0x26, 0x58, 0x3D, 0x56, 0x75, 0x50, 0x3B, 0x47, 0x26, 0x49, 0x31, 0x4E, 0x76, 0x52, 0x26, 0x03, 0x6F, 0x53, 0x37, 0x4A, 0x62, 0x54, 0x30, 0x56, 0x68, 0x49, 0x74, 0x56, 0x72, 0x1D, 0x38, 0x42, 0x64, 0x52, 0x26, 0x46, 0x26, 0x58, 0x20, 0x03, 0x62, 0x52, 0x38, 0x4C, 0x74, 0x58, 0x74, 0x4E, 0x67, 0x5A, 0x3A, 0x42, 0x26, 0x5C, 0x38, 0x4A, 0x77, 0x48, 0x35, 0x0D, 0x26, 0x68, 0x20, 0x03, 0x63, 0x53, 0x3D, 0x4E, 0x26, 0x5C, 0x30, 0x03, 0x6B, 0x54, 0x3A, 0x4A, 0x6B, 0x1D, 0x22, 0x46, 0x68, 0x54, 0x35, 0x4E, 0x2A, 0x1D, 0x25, 0x56, 0x6F, 0x4E, 0x74, 0x4D, 0x69, 0x4E, 0x20, 0x51, 0x73, 0x59, 0x74, 0x46, 0x7E, 0x58, 0x26, 0x40, 0x6F, 0x49, 0x35, 0x57, 0x6F, 0x52, 0x3A, 0x03, 0x73, 0x51, 0x38, 0x42, 0x6B, 0x5E, 0x3B, 0x03, 0x6A, 0x5C, 0x36, 0x4C, 0x74, 0x54, 0x27, 0x03, 0x68, 0x54, 0x27, 0x4A, 0x26, 0x48, 0x20, 0x03, 0x67, 0x51, 0x3D, 0x52, 0x73, 0x54, 0x24, 0x03, 0x63, 0x45, 0x74, 0x46, 0x67, 0x1D, 0x37, 0x4C, 0x6B, 0x50, 0x3B, 0x47, 0x69, 0x1D, 0x37, 0x4C, 0x68, 0x4E, 0x31, 0x52, 0x73, 0x5C, 0x20, 0x0D, 0x26, 0x79, 0x21, 0x4A, 0x75, 0x1D, 0x35, 0x56, 0x72, 0x58, 0x74, 0x4A, 0x74, 0x48, 0x26, 0x46, 0x26, 0x59, 0x3B, 0x4F, 0x69, 0x4F, 0x74, 0x4A, 0x68, 0x1D, 0x26, 0x46, 0x76, 0x4F, 0x31, 0x4B, 0x63, 0x53, 0x30, 0x46, 0x74, 0x54, 0x20, 0x03, 0x6F, 0x53, 0x74, 0x55, 0x69, 0x51, 0x21, 0x53, 0x72, 0x5C, 0x20, 0x46, 0x26, 0x4B, 0x31, 0x4F, 0x6F, 0x49, 0x74, 0x46, 0x75, 0x4E, 0x31, 0x03, 0x65, 0x54, 0x38, 0x4F, 0x73, 0x50, 0x74, 0x47, 0x69, 0x51, 0x3B, 0x51, 0x63, 0x1D, 0x31, 0x56, 0x26, 0x5B, 0x21, 0x44, 0x6F, 0x5C, 0x20, 0x03, 0x68, 0x48, 0x38, 0x4F, 0x67, 0x1D, 0x24, 0x42, 0x74, 0x54, 0x35, 0x57, 0x73, 0x4F, 0x7A, 0x03, 0x43, 0x45, 0x37, 0x46, 0x76, 0x49, 0x31, 0x56, 0x74, 0x1D, 0x27, 0x4A, 0x68, 0x49, 0x74, 0x4C, 0x65, 0x5E, 0x35, 0x46, 0x65, 0x5C, 0x20, 0x03, 0x65, 0x48, 0x24, 0x4A, 0x62, 0x5C, 0x20, 0x42, 0x72, 0x1D, 0x3A, 0x4C, 0x68, 0x1D, 0x24, 0x51, 0x69, 0x54, 0x30, 0x46, 0x68, 0x49, 0x78, 0x03, 0x75, 0x48, 0x3A, 0x57, 0x26, 0x54, 0x3A, 0x03, 0x65, 0x48, 0x38, 0x53, 0x67, 0x1D, 0x25, 0x56, 0x6F, 0x1D, 0x3B, 0x45, 0x60, 0x54, 0x37, 0x4A, 0x67, 0x1D, 0x30, 0x46, 0x75, 0x58, 0x26, 0x56, 0x68, 0x49, 0x74, 0x4E, 0x69, 0x51, 0x38, 0x4A, 0x72, 0x1D, 0x35, 0x4D, 0x6F, 0x50, 0x74, 0x4A, 0x62, 0x1D, 0x31, 0x50, 0x72, 0x1D, 0x38, 0x42, 0x64, 0x52, 0x26, 0x56, 0x6B, 0x13};
	char expected3[] = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.";

	test(frame1, sizeof(frame1), expected1, sizeof(expected1) - 1);
	test(frame2, sizeof(frame2), expected2, sizeof(expected2) - 1);
	test(frame3, sizeof(frame3), expected3, sizeof(expected3) - 1);

	return 0;
}
