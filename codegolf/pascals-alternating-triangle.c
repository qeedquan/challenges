/*

Pascal's triangle is generated by starting with 1 and having each row formed from successive additions. Here, instead, we're going to form a triangle by alternating multiplication and addition.

We start row 1 with just a solitary 1. Thereafter, addition is done on the odd rows, and multiplication is done on the even rows (1-indexed). When performing the addition step, assume the spaces outside of the triangle are filled with 0s. When performing the multiplication step, assume that the outside is filled with 1s.

Here's the full triangle down to 7 rows. The * or + on the left shows what step was performed to generate that row.

1                1
2 *            1   1
3 +          1   2   1
4 *        1   2   2   1
5 +      1   3   4   3   1
6 *    1   3  12  12   3   1
7 +  1   4  15  24  15   4   1
Challenge
Given input n, output the nth row of this triangle.

Rules
You may choose to 0-index instead, but then please realize that the addition and multiplication rows must flip-flop, so that the exact same triangle is generated as above. Please state in your submission if you choose to do this.
The input and output can be assumed to fit in your language's native integer type.
The input and output can be given in any convenient format.
Either a full program or a function are acceptable. If a function, you can return the output rather than printing it.
If possible, please include a link to an online testing environment so other people can try out your code!
Standard loopholes are forbidden.
This is code-golf so all usual golfing rules apply, and the shortest code (in bytes) wins.
Examples
Showing two possible examples of output out of many: a list, or a space separated string.

4
[1, 2, 2, 1]

8
"1 4 60 360 360 60 4 1"

*/

#include <assert.h>
#include <stdio.h>
#include <string.h>

void
show(int *a, size_t n)
{
	size_t i;

	for (i = 0; i < n; i++)
		printf("%d ", a[i]);
	printf("\n");
}

int *
gen(int n, int *r)
{
	int i, j;
	int *p, *q;

	p = r;
	p[0] = 1;
	for (i = 1; i < n; i++) {
		q = p + i + 1;
		q[0] = 1;
		q[i] = 1;
		for (j = 1; j < i; j++) {
			if (!(i & 1))
				q[j] = p[j - 1] + p[j];
			else
				q[j] = p[j - 1] * p[j];
		}
		p = q;
	}
	return p;
}

void
test(int n, int *r)
{
	int x[128];
	int *p;

	p = gen(n, x);
	show(p, n);
	assert(!memcmp(p, r, n * sizeof(*r)));
}

int
main()
{
	int r1[] = { 1 };
	int r2[] = { 1, 1 };
	int r3[] = { 1, 2, 1 };
	int r4[] = { 1, 2, 2, 1 };
	int r5[] = { 1, 3, 4, 3, 1 };
	int r6[] = { 1, 3, 12, 12, 3, 1 };
	int r7[] = { 1, 4, 15, 24, 15, 4, 1 };
	int r8[] = { 1, 4, 60, 360, 360, 60, 4, 1 };

	test(1, r1);
	test(2, r2);
	test(3, r3);
	test(4, r4);
	test(5, r5);
	test(6, r6);
	test(7, r7);
	test(8, r8);

	return 0;
}
