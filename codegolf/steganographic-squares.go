/*

Steganographic Squares
Your job is to take in a string, and generate an NxN image that represents this string. You must also write the algorithm that takes in the image and turns it back into a string as well. The scoring will be will include the byte count of both algorithms:

"Encryption" Algorithm + "Decryption" Algorithm.

You should post each separately, with byte-counts for both the encryption and decryption algorithms displayed individually.

Example Algorithm
For instance, here's the "Programming Puzzles and Code Golf" using a simple ASCII based steganographic algorithm in the Blue channel:

#2e7250,#6ea972,#04eb6f,#0fc767,#74ab72,#ee6161
#b73b6d,#1aae6d,#f37169,#bda56e,#1fe367,#e99620
#706450,#0d3575,#146b7a,#4ea47a,#2a856c,#95d065
#3f2d73,#cef720,#bab661,#d1b86e,#f22564,#12b820
#0f3d43,#c86e6f,#1ee864,#a66565,#247c20,#c3bb47
#0e296f,#89d46c,#585b66,#c08f20,#455c20,#136f20
Actual Image ( The image generated by the algorithm. )

Image blown-up.

You can see the blue channel simply holds the ascii values for this image:

50 =  80(P) 72 = 114(r) 6f = 111(o) 67 = 103(g) 72 = 114(r) 61 =  97(a)
6d = 109(m) 6d = 109(m) 69 = 105(i) 6e = 110(n) 67 = 103(g) 20 =  32( )
50 =  80(P) 75 = 117(u) 7a = 122(z) 7a = 122(z) 6c = 108(l) 65 = 101(e)
73 = 115(s) 20 =  32( ) 61 =  97(a) 6e = 110(n) 64 = 100(d) 20 =  32( )
43 =  67(C) 6f = 111(o) 64 = 100(d) 65 = 101(e) 20 =  32( ) 47 =  71(G)
6f = 111(o) 6c = 108(l) 66 = 102(f) 20 =  32( ) 20 =  32( ) 20 =  32( )
While the rest of the channels hold randomly generated values to "spice up" the variety of colors in the image. When pulling the message back out of the image, we can just simply ignore the other channel values, and pull the hex bit in the blue channel, reconstructing the string:

"Programming Puzzles and Code Golf"
Notice the spaces that were used to pad the string in the square are not included in the final decrypted output. While you must pad the string in the image, you may assume that the input string will not end with spaces.

Rules
You must encode 1 character per pixel, the channel chosen to encode the char is arbitrary.
The channels of the other RGB colors must be randomized, other than the one you're choosing to encode the string into; this means your final non-encoded channels would need to be between 0x0000-0xFFFF (randomly chosen).
Expressing the final result as a 2D array of RGB color values is fine 0x000000-0xFFFFFF, no need to use image creation unless you want to have fun with it or if it's less bytes. If you choose to output as hex strings, prefix the hex string with # E.G. #FFFFFF or #05AB1E. You may separate with tabs, commas, or anything else that would be horizontally sensible, but it must maintain the square pattern; in other words, you must use appropriate newline separation.
The output must be in a square, and the string must be padded with spaces at the end to accomodate this. This means that Nâ‰ˆSQRT(Input#Length()). If the input length is not a perfect square, you should round up on N and pad with spaces.
As stated previously, if you are padding with spaces in the image, you must not include the padded characters in the final "decrypted" output.
You can assume that:
The input string will not end with spaces.
The input string will only use printable ASCII characters.

This is code-golf, lowest byte count wins.

*/

package main

import (
	"bytes"
	"fmt"
	"image"
	"image/color"
	"math/rand"
	"strings"
)

func main() {
	const message = `
#2e7250,#6ea972,#04eb6f,#0fc767,#74ab72,#ee6161
#b73b6d,#1aae6d,#f37169,#bda56e,#1fe367,#e99620
#706450,#0d3575,#146b7a,#4ea47a,#2a856c,#95d065
#3f2d73,#cef720,#bab661,#d1b86e,#f22564,#12b820
#0f3d43,#c86e6f,#1ee864,#a66565,#247c20,#c3bb47
#0e296f,#89d46c,#585b66,#c08f20,#455c20,#136f20`

	assert(decrypt(hex2img(message)) == "Programming Puzzles and Code Golf   ")
	assert(decrypt(encrypt("hello world")) == "hello world")
}

func assert(x bool) {
	if !x {
		panic("assertion failed")
	}
}

func hex2img(s string) *image.RGBA {
	p := []color.RGBA{}
	l := strings.Split(s, "\n")
	w := 0
	h := 0
	for _, l := range l {
		if l == "" {
			continue
		}

		t := strings.Split(l, ",")
		for _, t := range t {
			var cr, cg, cb uint8

			fmt.Sscanf(t, "#%2x%2x%2x", &cr, &cg, &cb)
			p = append(p, color.RGBA{cr, cg, cb, 255})
		}

		if len(t) > w {
			w = len(t)
		}
		h++
	}

	m := image.NewRGBA(image.Rect(0, 0, w, h))
	i := 0
	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			m.SetRGBA(x, y, p[i])
			i++
		}
	}
	return m
}

func encrypt(s string) *image.RGBA {
	r := image.Rect(0, 0, len(s), 1)
	m := image.NewRGBA(r)
	for i := 0; i < len(s); i++ {
		c := color.RGBA{
			R: uint8(rand.Intn(255)),
			G: uint8(rand.Intn(255)),
			B: s[i],
			A: 255,
		}
		m.SetRGBA(i, 0, c)
	}
	return m
}

func decrypt(m *image.RGBA) string {
	w := new(bytes.Buffer)
	r := m.Bounds()
	for y := r.Min.Y; y < r.Max.Y; y++ {
		for x := r.Min.X; x < r.Max.X; x++ {
			c := m.RGBAAt(x, y)
			w.WriteByte(c.B)
		}
	}
	return w.String()
}
