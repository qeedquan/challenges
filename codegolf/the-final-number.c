/*

Challenge
https://i.stack.imgur.com/dqCkE.jpg

Write a program that takes an array of 4 integers (which represents a sequence of numbers generated by a certain algorithm) and returns the next integer that would follow.

We will only be using simple addition, subtraction, multiplication and division algorithms with a constant (i.e non-variable) variation.

For division we will use the floor integer values: 133/4 = 33 and 33/4 = 8

You can assume that there will always be one single valid return value

Test cases
[14,24,34,44] should return 54 (addition Algorithm)

[105,45,-15,-75] should return -135 (subtraction algorithm)

[5,25,125,625] should return 3125 (multiplicative algorithm)

[256,64,16,4] should return 1 (division algorithm)

General rules
This is code-golf, so the shortest answer in bytes wins the challenge.
Standard loopholes are forbidden

*/

#include <assert.h>
#include <math.h>

int
final(int a, int b, int c, int d)
{
	if (d - c == b - a)
		return (d * 2) - c;
	if (a == 0 || b == 0)
		return 0;
	return round(d / (a * 1.0 / b));
}

int
main(void)
{
	assert(final(14, 24, 34, 44) == 54);
	assert(final(105, 45, -15, -75) == -135);
	assert(final(5, 25, 125, 625) == 3125);
	assert(final(256, 64, 16, 4) == 1);
	assert(final(-6, -18, -54, -162) == -486);
	assert(final(261, 65, 16, 4) == 1);
	assert(final(261, 64, 16, 4) == 1);
	assert(final(325, 81, 20, 5) == 1);
	assert(final(1, 0, 0, 0) == 0);
	assert(final(2, 1, 0, 0) == 0);
	assert(final(1, 1, 1, 1) == 1);
	assert(final(0, 0, 0, 0) == 0);
	assert(final(-1, -1, -1, -1) == -1);
	assert(final(-325, -82, -21, -6) == -2);
	assert(final(325, -82, 20, -5) == 1);

	return 0;
}
