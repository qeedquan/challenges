/*

The Champernowne constant is a number that is constructed by concatenating the first n numbers, with n tending to infinity. It looks something like this:

0.123456789101112131415161718192021222324252627282930...
Now, I will describe to you the Rien number. It can be thought of as a minimization of the Champernowne constant as an integer. I will refer to the Rien number with the first n digits as Ri(n). This is how to formulate it:

The first n natural numbers (the sequence {1,2,3,...}) are concatenated.
This result is then sorted, according to the digit value. So 1..12 would look like 011111223456789.
Since the Rien number cannot have leading zeroes, we move all 0s so that they are significant, whilst keeping the number minimized, resulting in, say, 101111223456789. This is Ri(n), in this case, Ri(12).
Here are some results for Ri(n):

n    Ri(n)
1    1
2    12
3    123
7    1234567
9    123456789
10   10123456789
15   101111111223344556789
34   10001111111111111222222222222223333333334444555666777888999
42   100001111111111111122222222222222233333333333333444444455556666777788889999
45   100001111111111111122222222222222233333333333333344444444444555556666777788889999
55   10000011111111111111122222222222222223333333333333333444444444444444455555555555566666777778888899999
100  100000000000111111111111111111112222222222222222222233333333333333333333444444444444444444445555555555555555555566666666666666666666777777777777777777778888888888888888888899999999999999999999
999  100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
Objective Given a number 1 â‰¤ n < 10000 as input (via arguments, STDIN, or hardcoding if your language does not support conventional input), output/return Ri(n).

This is a code-golf, so the shortest code in bytes wins. You may use a language that was made after this contest, as long as it was not made for answering this challenge. (Of course, you can use it, if it provides an interesting solution, but mark your answer as non-competing.)

Reference implementation
I tested this in IE, so there really shouldn't be a problem. If there is a problem, there's an easy solution: get a sane browser.

function min(n) {
  var seq = [];
  for(var i = 1; i <= n; i++) seq.push(i);
  seq = seq.join("").split("").map(Number);
  var to;
  if(seq.indexOf(1) >= 0) to = seq.splice(seq.indexOf(1), 1);
  seq.sort(function(a, b) {
    return a - b;
  });
  if(to) seq = to.concat(seq);
  return seq.join("");
}
t.onchange = t.onkeyup = function() {
  h.innerHTML = min(this.value)
}
* {
  font-family: Consolas, monospace;
}
input {
  border: 2px dotted #aaaaaa;
  border-radius: 5px;
  margin: 10px;
}
<input id="t" type="number">
<div id="h">

*/

package main

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
)

func main() {
	assert(rien(1) == "1")
	assert(rien(2) == "12")
	assert(rien(3) == "123")
	assert(rien(7) == "1234567")
	assert(rien(9) == "123456789")
	assert(rien(10) == "10123456789")
	assert(rien(15) == "101111111223344556789")
	assert(rien(34) == "10001111111111111222222222222223333333334444555666777888999")
	assert(rien(42) == "100001111111111111122222222222222233333333333333444444455556666777788889999")
	assert(rien(45) == "100001111111111111122222222222222233333333333333344444444444555556666777788889999")
	assert(rien(55) == "10000011111111111111122222222222222223333333333333333444444444444444455555555555566666777778888899999")
	assert(rien(100) == "100000000000111111111111111111112222222222222222222233333333333333333333444444444444444444445555555555555555555566666666666666666666777777777777777777778888888888888888888899999999999999999999")
	assert(rien(999) == "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999")
}

func assert(x bool) {
	if !x {
		panic("assertion failed")
	}
}

func rien(n int) string {
	if n < 1 {
		return "0"
	}
	s := nat(n)
	i := strings.Index(s, "1")
	return s[i:i+1] + strings.Repeat("0", i) + s[i+1:]
}

func nat(n int) string {
	w := new(bytes.Buffer)
	for i := 1; i <= n; i++ {
		fmt.Fprint(w, i)
	}

	b := w.Bytes()
	sort.Slice(b, func(i, j int) bool {
		return b[i] < b[j]
	})

	return string(b)
}
