/*

Computing the number of swaps in insertion sort
Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time.
It is much less efficient on large lists than more advanced algorithms such as “Quick Sort”, “Heap Sort”, or “Merge Sort”.
However, insertion sort provides several advantages: simple implementation, efficient for (quite) small data sets, O(1) extra space.

When humans manually sort something (for example, a deck of playing cards), most use a method that is similar to insertion sort.

Source: Wikipedia

Although it is one of the elementary sorting algorithms with O(n^2) worst-case time,
insertion sort is the algorithm of choice either when the data is nearly sorted (because it is adaptive) or when the problem size is small (because it has low overhead).

For these reasons, and because it is also stable, insertion sort is often used as the recursive base case (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as “Merge Sort” or “Quick Sort”.

Visualization by David R. Martin: http://www.sorting-algorithms.com/insertion-sort

Problem
Insertion sort is a simple algorithm with quadratic running time that builds the final sorted array one item at a time.

https://rosalind.info/media/problems/ins/insertionsort.algo.png

Given: A positive integer n≤10^3 and an array A[1..n] of integers.

Return: The number of swaps performed by insertion sort algorithm on A[1..n].

Sample Dataset
6
6 10 4 5 1 2

Sample Output
12

Discussion
For this problem, it is enough to implement the pseudocode above with a quadratic running time and to count the number of swaps performed.
Note however that there exists an algorithm counting the number of swaps in O(nlogn).
Note also that Insertion Sort is an in-place algorithm as it only requires storing a few counters.

*/

fn main() {
    assert_eq!(insertions(&mut [6, 10, 4, 5, 1, 2]), 12);
    assert_eq!(
        insertions(&mut [
            4838, -55587, 81872, -93070, 63044, -74682, -10901, 44697, 54170, 56561, 44595, 35507,
            37214, 62063, 51985, -7287, -35389, 50052, -69104, -96788, 45578, 51508, 28514, -4309,
            -20105, 44211, 23860, -68995, 89077, -96566, 77003, -96537, 78070, -28217, 79652,
            -72956, 9656, 16718, 77477, 17590, -72694, -73551, -9513, -787, -89989, -84507, -89947,
            2094, 47540, -26114, -72930, -11239, 87851, 42920, -1157, -68179, -99365, -59682,
            -17700, -17103, 58157, -37961, -26508, 86475, 56782, 70533, -73330, 80176, -17509,
            82425, 93571, 68678, 67344, -24617, -11872, 61880, -86716, -87610, -17243, 53090,
            87170, 10541, 53260, -55499, -78749, -47507, -42642, -30072, 68423, -90765, 57649,
            6013, -44609, 12331, -35891, -78455, 36107, 23568, -82823, 91171, -43382, 86434,
            -40798, -54292, 63347, -21496, 45334, -79614, -79057, 20933, 4357, -58952, -59028,
            7209, -19317, -7747, 28707, -31675, 21720, 68700, -3517, -41263, 95513, -68207, 47417,
            -67551, -1065, 2349, -46947, 29305, 96762, 57027, -53439, -51731, 72832, -99217, 35744,
            -14999, -6249, 41253, 58900, -49672, -49563, 38140, 53306, -72088, -28525, 72947,
            84670, 77163, 52415, -54887, -17849, -22895, 46741, -42095, -16908, -92717, 14326,
            25155, -47446, 216, 21003, 62257, 78972, -52185, -18035, -96144, 875, 91456, -17454,
            -12856, -16063, -763, 85525, -82749, -2749, -38530, 90113, 48690, 18329, 5170, 29716,
            -8589, 95471, 84882, -99510, 19880, -43864, 71987, -20694, -37220, -89513, 36018,
            81993, -20656, -97825, -83521, -26868, -50815, -53253, 35432, 68338, 33121, -14962,
            61963, 16841, -76758, -33253, -88839, 60643, 30490, 72764, -6017, 51348, 58184, 72886,
            19260, -1148, 35882, 21552, -68079, -23022, 37017, -36496, 99965, -90665, -96928,
            -44548, 7783, -36821, 95419, 93740, 11493, 73137, -57161, 51916, -48815, -41580,
            -39821, -66971, -9300, 25443, 91113, -19757, 10569, -91837, 63585, -62681, 24495,
            -60389, 20870, 99139, 58458, -19348, 62920, 7576, 56732, -68910, 2791, -99732, -69549,
            4300, -93851, 69934, 66537, 32813, 92769, -75968, -61530, -5932, 65327, -20770, 54908,
            5953, -21085, 11505, -44999, -2669, 17973, 1352, -20390, 87668, 68971, -3649, -34542,
            -61574, -97496, -80728, -4834, -71729, -92519, -9365, 27929, -59732, 87519, -54085,
            -74002, 44521, -36377, 9759, 27287, 41073, 1268, -62473, -88177, -9882, -33398, -93322,
            73001, 44607, 58534, 44213, -59244, 95081, 80329, -46728, -6784, 10657, -93954, -48781,
            74520, 88798, 77629, 14729, -24816, 51007, -59109, 52635, 13822, -28859, 27165, -8686,
            -21619, -38473, 30622, 5557, 17582, 76332, 41439, 62456, 45514, -88781, 10199, -4557,
            3662, 83069, -84403, 5244, -82234, 20954, 98198, -63680, -73711, -27034, 2734, 94237,
            93263, -53635, 50057, -12409, -49568, 50901, -91800, -57967, -4011, 93030, -96803,
            -16067, -95226, 43068, 44724, 21509, 588, -78306, -22307, -78105, -96816, 24675, 3713,
            26993, -77300, 71903, -14834, 42502, -17870, 1184, 56895, 55955, 22461, 38397, 89751,
            -36306, -84122, -1835, 52238, -6200, -97354, -31138, 2349, 66592, 14085, -9072, 42852,
            87510, 43412, -88600, 22899, -3733, 51894, -11959, 21328, 46832, 68686, 80905, 37969,
            86938, -96264, 66879, 49053, -1739, -18649, -85210, -83353, 13411, -86579, -45441,
            68265, 28338, -72270, 28795, -14451, -48787, 93265, 63510, 95546, -71044, -40275,
            58630, -20721, 59111, 20607, 63473, -30483, -61956, -74507, -32894, -4323, 44925,
            -8423, 46486, 93553, -50247, -37490, -64992, 4352, -94506, 65715, -84136, -41591,
            61394, 84947, 8952, 23511, -65084, -86310, 65829, -15566, 19224, -72489, 73966, 17886,
            -63416, -3632, 82919, 97681, -75770, -99984, -88556, 10568, 13568, 35530, -97481,
            -50378, -55710, 8419, -22010, 72715, -51811, -7077, 69697, 19049, -32172, 89911, 6998,
            -16332, -76557, 62563, 56827, 69810, -44744, -77009, -98330, -47395, 45334, -34726,
            -43876, 92060, -1046, 95800, 45423, -18556, -68477, 28013, -50709, -92062, -93806,
            -26801, -26485, 48808, 57325, 73651, -8976, -94819, -61370, 58729, -44275, -11437,
            -55006, -506, -85831, 91510, -59724, -59999, 67433, 96844, -27599, 48138, -15648, 6956,
            28546, -27791, -71330, -17178, -19910, 79075, -71603, 61277, -25554, -22710, -2493,
            -11787, -44359, 14686, 20339, -37431, 6057, -51731, -13792, 34786, -73883, 60632,
            85847, -50810, -50396, 71984, -73737, -69817, -30589, 78401, 64071, 26939, -1982,
            48732, 20158, -53371, -25830, 22474, -34245, 82654, 36849, -96979, 23387, 47687,
            -57880, -74845, 42640, -11084, 19875, 76361, 6512, -49365, -90095, -90716, 4240,
            -12948, 57677, 6975, 16965, 12084, -17543, 23778, 36523, -62803, 66263, 64837, -81353,
            -19769, -75043, 77008, -36597, 53871, -98673, -98701, 88993, -64143, -68034, -57531,
            -16378, 54189, 24157, 91193, -96862, -6818, 64907, -22415, 49604, 48656, -26153, 76627,
            65866, -48591, 26128, 48564, -28834, -77618, -54788, 16093, -42230, -24477, 81791,
            -7939, 12416, 26567, -54339, 32083, -67010, 5001, 37385, 62699, 82738, 85649, -5606,
            47234, 38683, -31766, 22763, -25219, 55024, -45787, -29492, 98372, -58210, 31634,
            66360, -50888, -36674, 68544, -74942, 77343, 92422, -69714, -90936, -69070, 33147,
            -45565, 13485, 45960, -83086, -2787, -24723, -92330, -47548, 59338, -60267, 37608,
            60704, -77354, -72931, -64330, -86834, -66784, -59419, -67285, -81400, -79239, 34374,
            -47631, -73144, -5873, -95081, 83294, -59215, -82225, 33462, -97076, 14170, -57064,
            -17821, 18417, 50539, -12374, 90332, -15507, -16808, 82920, 9594, 20972, -31971, 11583,
            -60076, -41244, 77929, 38163, 53126, -4984, -22597, 33437, 16121, -55636, -1526, 44239,
            -39878, 92082, -84135, 2662, 20002, 67521, 59120, -19369, -34693, 84173, -86667,
            -60088, 28226, 32261, -87858, 54139, -96455, -36563, 78257, 11954, -89697, 35540,
            -70936, 74349, 69839, 46959, 40853, 57326, -38601, -19190, 68444, 8321, -5377, 94606,
            -78951, 26385, -38521, 56466, 47700, -51946, -35413, -98659, 71149, 13697, -97561,
            77849, -52861, -66031, 36033, 79771, -18480, -23894, 1923, -50688, -27418, 57721,
            38650, -68298, -33743, 94809, 19501, -63592, -94378, 5758, -80221, 61566, 71909,
            -50065, 25269, -92424, -96547, 53058, 34474, 59902, -63497, 84336, 95560, -37230,
            -35354, 84363, 68239, -50590, -76149, 15359, 43667, 16182, 55381, -38632, -11147,
            -30401, 49895, -20817, -692, -64812, -97090, 37377, -53893, -88005, 52752, -40481,
            32451, 83595, -33886, 8201, 87205, 67416, -1362, -74934, 49762, -77627, 14658, 55819,
            -97551, -23817, 27872, 49437, 87543, 14003, 77859, -90387, -68926, -2373, 77854,
            -19725, -91390, -5784, 23163, 22464, 44046, -66124, 93257, 79466, 414, -69925, -55714,
            -11739, -27147, -77813, 43293, -90987, 48828, 76267, 20481, -86241, -19812, 94808,
            -30134, 27001, 36316, 11658, 97680, 36265, 62425, -85040, -62401, -68185, 48081,
            -60040, -90393, 15297, 40408, 8015, 99739, -28835, 12552, -37511, 32159, 4919, -6209,
            -22128, -5477, 75032, -33793, 44938, -98261, -54516, 66823, 35380, -62102, -75851,
            41459, -25945, -67495, -46433, -6695, 82803, -92615, -8089, -50907, 37772, 62519,
            -44515, -37311, 67662, 93663
        ]),
        217246
    );

    assert_eq!(
        insertions(&mut [10, 9, 8, 7, 6, 4, 3, 2, 1]),
        insertionsbf(&mut [10, 9, 8, 7, 6, 4, 3, 2, 1])
    );
}

/*

https://www.geeksforgeeks.org/count-swaps-required-to-sort-an-array-using-insertion-sort/
The idea is to use merge sort to count the swaps

Time: O(n log n)
Space: O(n)

*/

fn insertions(a: &mut [isize]) -> usize {
    let n = a.len();
    if n == 0 {
        return 0;
    }
    return recurse(a, 0, n - 1, &mut vec![0; n]);
}

fn recurse(a: &mut [isize], l: usize, r: usize, x: &mut Vec<isize>) -> usize {
    let mut c = 0;
    if l < r {
        let m = l + (r - l) / 2;
        c += recurse(a, l, m, x);
        c += recurse(a, m + 1, r, x);
        c += merges(a, l, m + 1, r, x);
    }
    return c;
}

fn merges(a: &mut [isize], mut l: usize, m: usize, r: usize, x: &mut Vec<isize>) -> usize {
    let (mut c, mut i, mut j, mut k) = (0, l, m, l);
    while i < m && j <= r {
        if a[i] <= a[j] {
            (x[k], k, i) = (a[i], k + 1, i + 1);
        } else {
            (x[k], k, j, c) = (a[j], k + 1, j + 1, c + m - i);
        }
    }
    while i < m {
        (x[k], k, i) = (a[i], k + 1, i + 1);
    }
    while j <= r {
        (x[k], k, j) = (a[j], k + 1, j + 1);
    }
    while l <= r {
        (a[l], l) = (x[l], l + 1);
    }
    return c;
}

/*

Naive method:

Time: O(n^2)
Space: O(1)

*/

fn insertionsbf(a: &mut [isize]) -> usize {
    let mut c = 0;
    for i in 0..a.len() {
        let mut j = i;
        while j > 0 && a[j] < a[j - 1] {
            (a[j - 1], a[j]) = (a[j], a[j - 1]);
            c += 1;
            j -= 1;
        }
    }
    return c;
}
